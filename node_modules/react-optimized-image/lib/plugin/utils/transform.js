"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.buildRequireStatement = exports.addQueryToString = void 0;

var _querystring = _interopRequireDefault(require("querystring"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Add new query params to an existing require string
 *
 * @param {string} currentValue
 * @param {Record<string, unknown>} query
 * @returns {string}
 */
const addQueryToString = (currentValue, query) => {
  const parts = currentValue.split('?');
  const existing = parts.length > 1 ? _querystring.default.parse(parts[1]) : {};
  const newQuery = { ...existing,
    ...query
  };

  if (Object.keys(newQuery).length === 0) {
    return parts[0];
  }

  const stringified = Object.keys(newQuery).map(key => {
    const value = newQuery[key];

    if (Array.isArray(value)) {
      value.map(singleValue => `${_querystring.default.escape(key)}${typeof singleValue !== 'undefined' && singleValue !== '' ? `=${_querystring.default.escape(singleValue)}` : ''}`);
    }

    return `${_querystring.default.escape(key)}${typeof value !== 'undefined' && value !== '' ? `=${_querystring.default.escape(`${value}`)}` : ''}`;
  }).join('&');
  return `${parts[0]}?${stringified}`;
};
/**
 * Builds a new require statement with the given arguments and query params
 *
 * @param {Babel['types']} types
 * @param {CallExpression['arguments']} existingArguments
 * @param {Record<string, unkown>} query
 * @returns {CallExpression}
 */


exports.addQueryToString = addQueryToString;

const buildRequireStatement = (types, existingArguments, query) => {
  const args = [...existingArguments];

  if (args.length > 0) {
    // single string
    if (args[0].type === 'StringLiteral') {
      const newValue = addQueryToString(args[0].value, query);
      args[0] = types.stringLiteral(newValue);
    } // concatenated string


    if (args[0].type === 'BinaryExpression' && args[0].right.type === 'StringLiteral') {
      const newValue = addQueryToString(args[0].right.value, query);
      args[0].right = types.stringLiteral(newValue);
    } // template literal


    if (args[0].type === 'TemplateLiteral' && args[0].quasis.length > 0) {
      const newValue = addQueryToString(args[0].quasis[args[0].quasis.length - 1].value.raw, query);
      args[0].quasis[args[0].quasis.length - 1] = types.templateElement({
        raw: newValue,
        cooked: newValue
      }, args[0].quasis[args[0].quasis.length - 1].tail);
    }
  }

  return types.callExpression(types.identifier('require'), args);
};

exports.buildRequireStatement = buildRequireStatement;