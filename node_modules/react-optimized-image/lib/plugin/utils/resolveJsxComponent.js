"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _babelFileLoader = require("babel-file-loader");

var _babelExplodeModule = require("babel-explode-module");

var _traverse = require("./traverse");

var _jsx = require("./jsx");

/**
 * Resolves the correct export name from an import
 *
 * @param {string} exportName
 * @param {string} importPath
 * @returns {string}
 */
const simplifyExportName = (exportName, importPath) => {
  // handle path specific imports like react-optimized-image/lib/components/Svg
  if (exportName === 'default') {
    if (importPath.startsWith('react-optimized-image/lib/components/')) {
      return importPath.replace('react-optimized-image/lib/components/', '');
    }
  }

  return exportName;
};
/**
 * Checks if an import name belongs to the given module
 *
 * @param {string} importName
 * @param {string} module
 * @returns {boolean}
 */


const isModule = (importName, module) => {
  return importName === module || importName.startsWith(`${module}/`);
};
/**
 * Resolves styled components import
 *
 * @param {CallExpression} node
 * @param {Binding} binding
 * @returns {{ exportName?: string; moduleName?: string } | undefined}
 */


const resolveStyledComponentsImport = (node, binding) => {
  if (node.callee.type !== 'Identifier') {
    return;
  }

  const resolved = resolveImport(binding.scope.getBinding(node.callee.name)); // eslint-disable-line no-use-before-define

  if (resolved && resolved.moduleName && (isModule(resolved.moduleName, 'styled-components') || isModule(resolved.moduleName, '@emotion/styled'))) {
    if (node.arguments.length > 0 && node.arguments[0].type === 'Identifier') {
      return resolveImport(binding.scope.getBinding(node.arguments[0].name)); // eslint-disable-line no-use-before-define
    }
  }
};
/**
 * Resolves an import or require statement
 *
 * @param {Binding | undefined} binding
 * @returns {{ exportName?: string; moduleName?: string } | undefined}
 */


const resolveImport = binding => {
  // handle import statements
  if (binding && binding.kind === 'module' && (0, _traverse.isImport)(binding.path) && binding.path.parent.type === 'ImportDeclaration') {
    return {
      moduleName: binding.path.parent.source.value,
      exportName: (0, _traverse.getExportName)(binding.path.node)
    };
  } // handle require statements and other libraries like styled-components


  if (binding && binding.kind !== 'module' && binding.path.node.type === 'VariableDeclarator') {
    const {
      node
    } = binding.path; // check for require('react-optimized-image').default calls

    if (node.init && node.init.type === 'MemberExpression' && node.init.object.type === 'CallExpression') {
      return {
        moduleName: (0, _traverse.resolveRequireModule)(node.init.object),
        exportName: (0, _traverse.resolveRequireExportName)(node, binding)
      };
    } // check for `const { Svg } = require('react-optimized-image')` or `styled(Img)({})  calls


    if (node.init && node.init.type === 'CallExpression') {
      // handle styled-components
      if (node.init.callee.type === 'CallExpression' && node.init.callee.callee.type === 'Identifier') {
        return resolveStyledComponentsImport(node.init.callee, binding);
      } // handle transpiled styled-components


      if (node.init.callee.type === 'CallExpression' && node.init.callee.callee.type === 'MemberExpression' && node.init.callee.callee.object.type === 'CallExpression') {
        return resolveStyledComponentsImport(node.init.callee.callee.object, binding);
      }

      return {
        moduleName: (0, _traverse.resolveRequireModule)(node.init),
        exportName: (0, _traverse.resolveRequireExportName)(node, binding)
      };
    } // handle styled-components (styled(Img)`...`)


    if (node.init && node.init.type === 'TaggedTemplateExpression' && node.init.tag.type === 'CallExpression' && node.init.tag.callee.type === 'Identifier') {
      return resolveStyledComponentsImport(node.init.tag, binding);
    } // handle recursiveness


    if (node.init && node.init.type === 'Identifier') {
      return resolveImport(binding.scope.getBinding(node.init.name));
    }
  }

  return undefined;
};
/**
 * Resolves a local import
 *
 * @param {Binding | undefined} binding
 * @param {string} moduleName
 * @param {string} exportName
 * @returns {{ exportName?: string; moduleName?: string } | undefined}
 */


const resolveLocalImportBinding = (binding, moduleName, exportName) => {
  if (binding.path.hub.file.opts.filename) {
    // resolve and parse file
    const filePath = (0, _babelFileLoader.resolveFilePathSync)(binding.path, moduleName);

    if (!filePath) {
      return undefined;
    }

    const parsedFile = (0, _babelFileLoader.loadFileSync)(filePath, binding.path.hub.file.opts.parserOpts);
    const exploded = (0, _babelExplodeModule.explodeModule)(parsedFile.path.parent);
    const exportStatement = exploded.exports.find(e => e.external === exportName);

    if (!exportStatement) {
      return undefined;
    }

    return parsedFile.scope.getBinding(exportStatement.local);
  }

  return undefined;
};
/**
 * Gets the JSX component name belonging to the import statement
 *
 * @param {Binding} [binding]
 * @returns {string}
 */


const getImportedJsxComponent = binding => {
  const resolved = resolveImport(binding); // follow local imports

  if (resolved && resolved.moduleName && (resolved.moduleName.startsWith('./') || resolved.moduleName.startsWith('../')) && resolved.exportName && binding) {
    const resolvedBinding = resolveLocalImportBinding(binding, resolved.moduleName, resolved.exportName);
    return getImportedJsxComponent(resolvedBinding);
  }

  if (resolved && resolved.exportName && resolved.moduleName && isModule(resolved.moduleName, 'react-optimized-image')) {
    return simplifyExportName(resolved.exportName, resolved.moduleName);
  }
};
/**
 * Resolves a JSXMemberExpression recursively into binding names
 *
 * @param {JSXMemberExpression} node
 * @returns {string}
 */


const resolveJsxMemberExpression = node => {
  let bindings = [];

  if (node.object.type === 'JSXMemberExpression') {
    bindings = [...resolveJsxMemberExpression(node.object)];
  } else if (node.object.type === 'JSXIdentifier') {
    bindings.push(node.object.name);
  }

  bindings.push(node.property.name);
  return bindings;
};
/**
 * Resolves a MemberExpression recursively into binding names
 *
 * @param {MemberExpression} node
 * @returns {string}
 */


const resolveMemberExpression = node => {
  let bindings = [];

  if (node.object.type === 'MemberExpression') {
    bindings = [...resolveMemberExpression(node.object)];
  } else if (node.object.type === 'Identifier') {
    bindings.push(node.object.name);
  }

  bindings.push(node.property.name);
  return bindings;
};
/**
 * Resolves a ObjectProperty recursively into binding names
 *
 * @param {NodePath<ObjectExpression>} path
 * @param {ObjectProperty} property
 * @returns {string}
 */


const resolveObjectProperty = (path, property) => {
  let bindings = [];
  const parent = path.findParent(() => true);

  if (parent.node.type === 'ObjectProperty') {
    bindings = [...resolveObjectProperty(parent.findParent(() => true), parent.node)];
  } else if (parent.node.type === 'VariableDeclarator' && parent.node.id.type === 'Identifier') {
    bindings.push(parent.node.id.name);
  }

  bindings.push(property.key.name);
  return bindings;
};
/**
 * Checks if two array equal
 *
 * @param {any[]} arr1
 * @param {any[]} arr2
 * @returns {boolean}
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any


const arraysMatch = (arr1, arr2) => {
  if (arr1.length !== arr2.length) {
    return false;
  }

  for (let i = 0; arr1.length < i; i += 1) {
    if (arr1[i] !== arr2[i]) {
      return false;
    }
  }

  return true;
};
/**
 * Resolves an object into a binding
 *
 * @param {Babel['types']} types
 * @param {NodePath<JSXElement>} path
 * @param {string[]} bindings
 */


const resolveObject = (types, path, bindings) => {
  if (bindings.length < 2) {
    return;
  }

  const variableName = bindings[bindings.length - 1];
  const object = path.scope.getBinding(bindings[0]);

  if (!object) {
    return;
  }

  const program = path.findParent(node => node.isProgram());
  let declarationPath = null; // eslint-disable-line

  let initializer; // search for object declaration

  program.traverse({
    // styles.StyledImg = ...
    MemberExpression(exPath) {
      if (exPath.node.property && exPath.node.property.name === variableName) {
        const exBindings = resolveMemberExpression(exPath.node);

        if (arraysMatch(bindings, exBindings) && exPath.parent.type === 'AssignmentExpression') {
          declarationPath = exPath;
          initializer = exPath.parent.right;
          exPath.stop();
        }
      }
    },

    // const styles = { StyledImg: ... }
    ObjectProperty(opPath) {
      if (opPath.node.key && opPath.node.key.type === 'Identifier' && opPath.node.key.name === variableName) {
        const exBindings = resolveObjectProperty(opPath.findParent(() => true), opPath.node);

        if (arraysMatch(bindings, exBindings)) {
          declarationPath = opPath;
          initializer = opPath.node.value;
          opPath.stop();
        }
      }
    }

  });

  if (!declarationPath) {
    return;
  }

  declarationPath = declarationPath; // mock a binding

  const binding = {
    kind: 'const',
    scope: declarationPath.scope,
    identifier: types.identifier(variableName),
    path: { ...declarationPath,
      // eslint-disable-line
      node: types.variableDeclarator(types.objectPattern([types.objectProperty(types.identifier(variableName), types.identifier(variableName))]), initializer)
    }
  };
  return binding;
};
/**
 * Resolves an react-optimized-image JSX component
 *
 * @param {NodePath<JSXElement>} path
 * @returns {string}
 */


const resolveJsxComponent = (types, path) => {
  // check if it is a possible react-optimized-image component before proceeding further
  const srcAttribute = (0, _jsx.getAttribute)(path, 'src');

  if (!srcAttribute) {
    return;
  }

  const requireName = (0, _traverse.getRelevantRequireString)(types, srcAttribute); // check if the imported src is not an image in case an extension is present

  if ((!requireName || !requireName.match(/\.(jpe?g|png|svg|gif|webp)($|\?)/gi)) && requireName !== '') {
    return;
  } // it is now likely to be a react-optimized-image component, so start resolving
  // check for a normal opening element (<Img ...)


  if (path.node.openingElement.name.type === 'JSXIdentifier') {
    const binding = path.scope.getBinding(path.node.openingElement.name.name);
    const component = getImportedJsxComponent(binding);
    return component;
  } // check for an object opening element (<styles.Img ...)


  if (path.node.openingElement.name.type === 'JSXMemberExpression') {
    const objectBindings = resolveJsxMemberExpression(path.node.openingElement.name);
    const resolvedBinding = resolveObject(types, path, objectBindings);
    const component = getImportedJsxComponent(resolvedBinding);
    return component;
  }
};

var _default = resolveJsxComponent;
exports.default = _default;