"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getNumberedArrayAttribute = exports.getTypeAttribute = exports.getBooleanAttribute = exports.getAttribute = void 0;

/**
 * Gets the specified attribute of a JSX component
 *
 * @param {NodePath<JSXElement>} path
 * @param {string} attributeName
 * @returns {NodePath<JSXAttribute> | undefined}
 */
const getAttribute = (path, attributeName) => {
  if (path.node.openingElement.attributes) {
    let attribue;
    path.get('openingElement').traverse({
      JSXAttribute(attributePath) {
        if (attributePath.node.name.name === attributeName) {
          attribue = attributePath;
          attributePath.stop();
        }
      }

    });
    return attribue;
  }

  return undefined;
};
/**
 * Gets the value of a boolean JSX attribute
 *
 * @param {NodePath<JSXElement>} path
 * @param {string} attributeName
 * @returns {boolean | undefined}
 */


exports.getAttribute = getAttribute;

const getBooleanAttribute = (path, attributeName) => {
  const attribute = getAttribute(path, attributeName);

  if (attribute) {
    if (attribute.node.value === null) {
      return true;
    }

    if (attribute.node.value.type === 'JSXExpressionContainer' && attribute.node.value.expression.type === 'BooleanLiteral') {
      return attribute.node.value.expression.value;
    } // todo: better error message with link to docs when ready & create test for this error


    throw attribute.get('value').buildCodeFrameError('Only static boolean values are allowed');
  }

  return undefined;
};
/**
 * Returns and validates the type argument
 *
 * @param {NodePath<JSXElement>} path
 * @param {string[]} types
 * @returns {string|undefined}
 */


exports.getBooleanAttribute = getBooleanAttribute;

const getTypeAttribute = (path, types) => {
  const attribute = getAttribute(path, 'type');

  if (attribute && attribute.node.value && attribute.node.value.type === 'StringLiteral') {
    const type = attribute.node.value.value;

    if (types.indexOf(type) < 0) {
      throw attribute.get('value').buildCodeFrameError(`Type ${type} not found in images.config.js`);
    }

    return type;
  }

  if (attribute && attribute.node) {
    throw attribute.get('value').buildCodeFrameError('Only static string values are allowed');
  }
};
/**
 * Gets the value of a numbered array JSX attribute
 *
 * @param {NodePath<JSXElement>} path
 * @param {string} attributeName
 * @returns {number[] | undefined}
 */


exports.getTypeAttribute = getTypeAttribute;

const getNumberedArrayAttribute = (path, attributeName) => {
  const attribute = getAttribute(path, attributeName);

  if (attribute) {
    if (attribute.node.value && attribute.node.value.type === 'JSXExpressionContainer' && attribute.node.value.expression.type === 'ArrayExpression') {
      const values = [];
      attribute.node.value.expression.elements.forEach((element, i) => {
        if (element && element.type === 'NumericLiteral') {
          values.push(element.value);
        } else if (element) {
          // todo: better error message with link to docs when ready & create test for this error
          throw attribute.get('value').get('expression').get(`elements.${i}`).buildCodeFrameError('Only static number values are allowed');
        }
      });
      return values;
    } // todo: better error message with link to docs when ready & create test for this error


    throw attribute.get('value').buildCodeFrameError('Only static array with number values is allowed');
  }

  return undefined;
};

exports.getNumberedArrayAttribute = getNumberedArrayAttribute;