"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _clone = _interopRequireDefault(require("clone"));

var _jsx = require("../utils/jsx");

var _transform = require("../utils/transform");

var _traverse = require("../utils/traverse");

var _imageConfig = require("../imageConfig");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const globalImageConfig = (0, _imageConfig.getGlobalConfig)();
/**
 * Build the image configuration based on jsx attribute
 *
 * @param {Babel['types']} types
 * @param {NodePath<JSXElement>} path
 * @returns {ImageConfig}
 */

const buildConfig = (types, path) => {
  // build config
  let config = { ...(globalImageConfig.default || {})
  }; // check if a specific type is set

  const type = (0, _jsx.getTypeAttribute)(path, Object.keys(globalImageConfig.types || {})); // add type configs

  if (type && globalImageConfig.types && globalImageConfig.types[type]) {
    config = { ...config,
      ...globalImageConfig.types[type]
    };
  } // check boolean attributes: webp, inline, url, original


  ['webp', 'inline', 'url', 'original'].forEach(attr => {
    const value = (0, _jsx.getBooleanAttribute)(path, attr);

    if (typeof value !== 'undefined') {
      config[attr] = value;
    } else if (typeof value === 'undefined' && config[attr] === true) {
      // add attr from global image config
      path.get('openingElement').pushContainer('attributes', types.jsxAttribute(types.jsxIdentifier(attr), null));
    }
  }); // get sizes

  const sizes = (0, _jsx.getNumberedArrayAttribute)(path, 'sizes');

  if (typeof sizes !== 'undefined') {
    config.sizes = sizes;
  } else if (config.sizes) {
    // add sizes attr from global image config
    path.get('openingElement').pushContainer('attributes', types.jsxAttribute(types.jsxIdentifier('sizes'), types.jsxExpressionContainer(types.arrayExpression(config.sizes.map(size => types.numericLiteral(size))))));
  } // get densities


  const densities = (0, _jsx.getNumberedArrayAttribute)(path, 'densities');

  if (typeof densities !== 'undefined') {
    config.densities = densities;
  } else if (config.densities) {
    // add densities attr from global image config
    path.get('openingElement').pushContainer('attributes', types.jsxAttribute(types.jsxIdentifier('densities'), types.jsxExpressionContainer(types.arrayExpression(config.densities.map(size => types.numericLiteral(size))))));
  } // get breakpoints


  const breakpoints = (0, _jsx.getNumberedArrayAttribute)(path, 'breakpoints');

  if (typeof breakpoints !== 'undefined') {
    config.breakpoints = breakpoints;
  } else if (config.breakpoints) {
    // add breakpoints attr from global image config
    path.get('openingElement').pushContainer('attributes', types.jsxAttribute(types.jsxIdentifier('breakpoints'), types.jsxExpressionContainer(types.arrayExpression(config.breakpoints.map(size => types.numericLiteral(size))))));
  }

  return config;
};
/**
 * Build the rawSrc attribute according to the image config
 *
 * @param {Babel['types']} types
 * @param {CallExpression['arguments']} requireArgs
 * @param {ImageConfig} config
 * @param {Record<string, unknown>} globalQuery
 * @returns {JSXAttribute}
 */


const buildRawSrcAttribute = (types, requireArgs, config, globalQuery) => {
  const properties = [];
  ['fallback', ...(config.webp ? ['webp'] : [])].forEach(type => {
    const typeProperties = [];
    const query = type === 'webp' ? { ...globalQuery,
      webp: ''
    } : { ...globalQuery
    };
    (config.sizes && config.sizes.length > 0 ? config.sizes : ['original']).forEach((size, index, allSizes) => {
      const sizeProperties = []; // only inline image if there is 1 size and no fallback

      if (typeof query.url === 'undefined' && typeof query.inline === 'undefined' && (type === 'fallback' && config.webp || allSizes.length > 1 || (config.densities || [1]).length > 1)) {
        query.url = '';
      }

      (config.densities || [1]).forEach(density => {
        const sizeQuery = { ...query,
          ...(typeof size === 'number' ? {
            width: `${size * density}`
          } : {})
        };
        sizeProperties.push(types.objectProperty(types.numericLiteral(density), (0, _transform.buildRequireStatement)(types, (0, _clone.default)(requireArgs), sizeQuery)));
      });
      typeProperties.push(types.objectProperty(typeof size === 'string' ? types.identifier(size) : types.numericLiteral(size), types.objectExpression(sizeProperties)));
    });
    properties.push(types.objectProperty(types.identifier(type), types.objectExpression(typeProperties)));
  });
  return types.jsxAttribute(types.jsxIdentifier('rawSrc'), types.jsxExpressionContainer(types.objectExpression(properties)));
};
/**
 * Process attribute on the img component and convert them to raw sources
 */


const transformImgComponent = (types, path) => {
  // abort if it has already the rawSrc attribute
  if ((0, _jsx.getAttribute)(path, 'rawSrc')) {
    return;
  } // get src attribute


  const src = (0, _jsx.getAttribute)(path, 'src');
  const requireArgs = src ? (0, _traverse.getRequireArguments)(types, src) : undefined;

  if (!src || !requireArgs) {
    return;
  }

  const config = buildConfig(types, path);
  const query = {}; // add boolean queries

  ['inline', 'url', 'original'].forEach(attr => {
    if (config[attr] === true) {
      query[attr] = '';
    }
  }); // transfer original src attribute if a new query param needs to be set

  if (Object.keys(query).length > 0) {
    src.get('value').replaceWith(types.jsxExpressionContainer((0, _transform.buildRequireStatement)(types, (0, _clone.default)(requireArgs), query)));
  }

  const rawSrc = buildRawSrcAttribute(types, requireArgs, config, query);
  path.get('openingElement').pushContainer('attributes', rawSrc);
};

var _default = transformImgComponent;
exports.default = _default;